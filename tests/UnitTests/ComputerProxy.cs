using System;
using System.Collections.Concurrent;

namespace HotAssembly.UnitTests
{


    /// <summary>
    /// This class fakes the instance of the remote class, although no real class is being 
    /// sent back to the original app domain. This class is being instantiated by the local instantiator
    /// </summary>
    [Serializable]
    public class ComputerProxy : IComputer, IDisposable
    {
        private readonly Guid _remoteInstanceHandle;
        private readonly RemoteComputerProxy _remoteComputerProxy;

        public ComputerProxy(Guid remoteInstanceHandle, RemoteComputerProxy remoteComputerProxy)
        {
            _remoteInstanceHandle = remoteInstanceHandle;
            _remoteComputerProxy = remoteComputerProxy;
        }

        public string GetAppDomain()
        {
            return _remoteComputerProxy.GetAppDomain(_remoteInstanceHandle);
        }

        public void Dispose()
        {
            _remoteComputerProxy?.DisposeInstance(_remoteInstanceHandle);
        }
    }



    /// <summary>
    /// this is a class that is generated by a remote instantiator and lives in the second app domain and facilitates all communication and instantiation.
    /// It comes down to the caller appdomain via a transparent proxy
    /// 
    /// todo: do I need to implement an interface here?
    /// </summary>
    public class RemoteComputerProxy : MarshalByRefObject
    {
        private readonly ConcurrentDictionary<Guid, IComputer> _instances = new ConcurrentDictionary<Guid, IComputer>();

        public Guid CreateInstance(params object[] args)
        {
            var instanceHandle = Guid.NewGuid();

            if (_instances.TryAdd(instanceHandle, new Computer.Computer()))
            {
                return instanceHandle;
            }

            else return Guid.Empty;
        }

        public string GetAppDomain(Guid instanceHandle)
        {
            IComputer instance;
            if (_instances.TryGetValue(instanceHandle, out instance))
            {
                return instance.GetAppDomain();
            }

            return null;
        }

        public void DisposeInstance(Guid instanceHandle)
        {
            IComputer instance;
            _instances.TryRemove(instanceHandle, out instance);
        }
    }
}
